/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All private, user-specific data (profiles, game progress, notification settings) is nested within a user's own document tree, ensuring that users can only ever access their own information. A separate top-level collection contains public, read-only data available to all users.
 *
 * Data Structure: The data is organized into a top-level `/users/{userId}` collection which contains user profile documents. Each user document serves as a root for their private subcollections: `/gameProgress`, `/notificationSchedules`, and `/deviceTokens`. A separate top-level `/games` collection stores public information about the games themselves.
 *
 * Key Security Decisions:
 * - Strict User Scoping: Access to any document under `/users/{userId}` is strictly limited to the authenticated user whose UID matches the `userId` in the path. This prevents users from accessing each other's data.
 * - No User Enumeration: Listing the root `/users` collection is explicitly disallowed to protect user privacy and prevent scraping of user profiles.
 * - Public Read-Only Data: The `/games` collection is publicly readable by anyone, including unauthenticated users, but is locked down to prevent any client-side writes. This makes it suitable for serving static, admin-managed content.
 * - Relational Integrity: On creation, documents within a user's data tree must contain a `userId` field that correctly references the parent user, enforcing data consistency. This `userId` field is immutable once set.
 *
 * Denormalization for Authorization: The data structure is inherently optimized for security rules. By nesting user-specific data like `gameProgress` and `deviceTokens` under the `/users/{userId}` path, ownership is determined by the document path itself. This avoids the need for slow and costly `get()` calls to check permissions on related documents.
 *
 * Structural Segregation: The ruleset follows a clear segregation pattern. Private user data is stored entirely separately from public game data. This creates a homogeneous security posture within each collection, simplifying rules and improving query performance and security.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    function isSignedIn() {
      return request.auth != null;
    }
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
    // Validates that the user ID inside the document matches the path on create.
    function hasValidUserIdOnCreate(userId) {
      return request.resource.data.userId == userId;
    }
    // Enforces immutability of the user ID on update.
    function userIdIsImmutable() {
      return request.resource.data.userId == resource.data.userId;
    }
    // Validates the root User document's ID on create.
    function hasValidIdOnCreate(userId) {
      return request.resource.data.id == userId;
    }
    // Enforces immutability of the root User document's ID on update.
    function idIsImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow A signed-in user (auth.uid: 'user_abc') can (create) their own profile at /users/user_abc.
     * @allow A signed-in user (auth.uid: 'user_abc') can (get) or (update) their own profile at /users/user_abc.
     * @deny A signed-in user (auth.uid: 'user_xyz') cannot (get) another user's profile at /users/user_abc.
     * @deny No user can (list) the /users collection to prevent user enumeration.
     * @principle Restricts access to a user's own data tree and enforces self-creation.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && hasValidIdOnCreate(userId);
      allow update: if isExistingOwner(userId) && idIsImmutable();
      allow delete: if false;

      /**
       * @description Secures a user's device tokens for push notifications.
       * @path /users/{userId}/deviceTokens/{deviceTokenId}
       * @allow A signed-in user (auth.uid: 'user_abc') can (create) and (delete) their own device tokens.
       * @deny A user cannot update a token, they should create a new one.
       * @principle Enforces ownership and ensures tokens are managed securely per-device.
       */
      match /deviceTokens/{deviceTokenId} {
          allow get: if isOwner(userId);
          allow list: if isOwner(userId);
          allow create: if isOwner(userId);
          allow delete: if isOwner(userId);
          allow update: if false; // Tokens should be created/deleted, not updated.
      }
    }

    /**
     * @description Secures a user's individual game progress records.
     * @path /users/{userId}/gameProgress/{gameProgressId}
     * @allow A signed-in user (auth.uid: 'user_abc') can (create) a new record at /users/user_abc/gameProgress/gp_123.
     * @allow A signed-in user (auth.uid: 'user_abc') can (list) all their records under /users/user_abc/gameProgress.
     * @deny A signed-in user (auth.uid: 'user_xyz') cannot (update) a record at /users/user_abc/gameProgress/gp_123.
     * @principle Enforces document ownership for all operations within a user's private subcollection.
     */
    match /users/{userId}/gameProgress/{gameProgressId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && hasValidUserIdOnCreate(userId);
      allow update: if isExistingOwner(userId) && userIdIsImmutable();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages access to user-specific notification schedules.
     * @path /users/{userId}/notificationSchedules/{notificationScheduleId}
     * @allow A signed-in user (auth.uid: 'user_abc') can (create) a schedule at /users/user_abc/notificationSchedules/ns_456.
     * @allow A signed-in user (auth.uid: 'user_abc') can (delete) their own schedule at /users/user_abc/notificationSchedules/ns_456.
     * @deny A signed-in user (auth.uid: 'user_xyz') cannot (list) schedules from /users/user_abc/notificationSchedules.
     * @principle Enforces document ownership and validates relational integrity between documents.
     */
    match /users/{userId}/notificationSchedules/{notificationScheduleId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && hasValidUserIdOnCreate(userId);
      allow update: if isExistingOwner(userId) && userIdIsImmutable();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Provides public, read-only access to game information.
     * @path /games/{gameId}
     * @allow Any user, including unauthenticated visitors, can (get) a document at /games/game_123.
     * @allow Any user, including unauthenticated visitors, can (list) the entire /games collection.
     * @deny No user can (create), (update), or (delete) any game document.
     * @principle Secures public data by allowing universal read access while denying all client-side writes.
     */
    match /games/{gameId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}
